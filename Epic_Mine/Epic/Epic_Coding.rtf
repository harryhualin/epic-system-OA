{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red127\green0\blue85;\red106\green62\blue62;\red42\green0\blue255;
\red63\green127\blue95;\red0\green0\blue192;}
\margl1440\margr1440\vieww16220\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Well Ordered String
\b0 \
\pard\pardeftab720

\f1\fs22 \cf0 	\
	\cf2 public\cf0  \cf2 static\cf0  List<String> printPassword(\cf2 int\cf0  \cf3 num\cf0 ) \{\
		List<String> \cf3 rst\cf0  = \cf2 new\cf0  ArrayList<>();\
		\cf2 if\cf0  (\cf3 num\cf0  <= 0)\
			\cf2 return\cf0  \cf3 rst\cf0 ;\
		findPassword(\cf3 num\cf0 , \cf3 rst\cf0 , \cf4 ""\cf0 , 0, 0);\
		\cf2 return\cf0  \cf3 rst\cf0 ;\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 void\cf0  findPassword(\cf2 int\cf0  \cf3 num\cf0 , List<String> \cf3 rst\cf0 , String \cf3 str\cf0 , \cf2 int\cf0  \cf3 curr\cf0 , \cf2 int\cf0  \cf3 diff\cf0 ) \{\
		\cf2 if\cf0  (\cf3 str\cf0 .length() == \cf3 num\cf0 ) \{\
			\cf3 rst\cf0 .add(\cf3 str\cf0 .toString());\
			\cf2 return\cf0 ;\
		\}\
		\
		\cf2 for\cf0 (\cf2 int\cf0  \cf3 i\cf0  = \cf3 diff\cf0 ; \cf3 i\cf0  < 26; \cf3 i\cf0 ++)\{\
			findPassword(\cf3 num\cf0 , \cf3 rst\cf0 , \cf3 str\cf0  + (\cf2 char\cf0 )(\cf4 'a'\cf0  + \cf3 i\cf0 ), \cf3 curr\cf0  + 1, \cf3 diff\cf0  + 1);\
			findPassword(\cf3 num\cf0 , \cf3 rst\cf0 , \cf3 str\cf0  + (\cf2 char\cf0 )(\cf4 'A'\cf0  + \cf3 i\cf0 ), \cf3 curr\cf0  + 1, \cf3 diff\cf0  + 1);\
		\}\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 SMS\

\f1\b0\fs22 \
\pard\pardeftab720
\cf0 	\cf2 public\cf0  \cf2 static\cf0  String translate(String \cf3 digits\cf0 ) \{\
		\cf2 if\cf0  (\cf3 digits\cf0  == \cf2 null\cf0  || \cf3 digits\cf0 .length() == 0)\
			\cf2 return\cf0  \cf3 digits\cf0 ;\
\
		String[] \cf3 map\cf0  = \{\cf4 "0"\cf0 ,\cf4 "1"\cf0 ,\cf4 "ABC2"\cf0 ,\cf4 "DFE3"\cf0 ,\cf4 "GHI4"\cf0 ,\cf4 "JKL5"\cf0 ,\cf4 "MNO6"\cf0 ,\cf4 "PQRS7"\cf0 ,\cf4 "TUV8"\cf0 ,\cf4 "WXYZ9"\cf0 \};\
		StringBuilder \cf3 sb\cf0  = \cf2 new\cf0  StringBuilder();\
		\
		\cf2 for\cf0  (\cf2 int\cf0  \cf3 i\cf0  = 0; \cf3 i\cf0  < \cf3 digits\cf0 .length(); \cf3 i\cf0 ++) \{\
			\cf2 char\cf0  \cf3 curr\cf0  = \cf3 digits\cf0 .charAt(\cf3 i\cf0 );\
			\cf2 if\cf0  (\cf3 curr\cf0  == \cf4 '#'\cf0 )\
				\cf2 continue\cf0 ;\
			\cf2 if\cf0  (\cf3 curr\cf0  == \cf4 '*'\cf0 ) \{\
				\cf3 sb\cf0 .append(\cf4 ' '\cf0 );\
			\} \cf2 else\cf0  \{ \cf5 // \ul curr\ulnone  >= '0' && \ul curr\ulnone  <= '9'\cf0 \
				\cf2 int\cf0  \cf3 index\cf0  = 0;\
				\cf2 while\cf0  (\cf3 i\cf0  + 1 < \cf3 digits\cf0 .length() && \cf3 digits\cf0 .charAt(\cf3 i\cf0  + 1) == \cf3 curr\cf0 ) \{\
					\cf3 i\cf0 ++;\
					\cf3 index\cf0 ++;\
				\}\
				String \cf3 str\cf0  = \cf3 map\cf0 [\cf3 curr\cf0  - \cf4 '0'\cf0 ]; \cf5 // how to convert char to \ul int\cf0 \ulnone \
				\cf3 sb\cf0 .append(\cf3 str\cf0 .charAt(\cf3 index\cf0  % \cf3 str\cf0 .length()));\
			\}\
		\}\
		\cf2 return\cf0  \cf3 sb\cf0 .toString();\
	\}\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Stepping Number\

\f1\b0\fs22 \
\pard\pardeftab720
\cf0 	\cf2 public\cf0  \cf2 static\cf0  List<Integer> findSteppingNumber(\cf2 int\cf0  \cf3 start\cf0 , \cf2 int\cf0  \cf3 end\cf0 ) \{\
		List<Integer> \cf3 rst\cf0  = \cf2 new\cf0  ArrayList<>();\
		\cf2 if\cf0  (\cf3 start\cf0  > \cf3 end\cf0 )\
			\cf2 return\cf0  \cf3 rst\cf0 ;\
		String \cf3 s\cf0  = String.valueOf(\cf3 start\cf0 );\
		String \cf3 e\cf0  = String.valueOf(\cf3 end\cf0 );\
		\cf2 for\cf0  (\cf2 int\cf0  \cf3 len\cf0  = \cf3 s\cf0 .length(); \cf3 len\cf0  <= \cf3 e\cf0 .length(); \cf3 len\cf0 ++) \{\
			\cf2 for\cf0  (\cf2 int\cf0  \cf3 curr\cf0  = 1; \cf3 curr\cf0  <= 9; \cf3 curr\cf0 ++) \{\
				helper(\cf3 rst\cf0 , \cf3 start\cf0 , \cf3 end\cf0 , \cf3 len\cf0  - 1, \cf3 curr\cf0 ); \cf5 // "\ul curr\ulnone " has taken "1"\cf0 \
			\}\
		\}\
		\cf2 return\cf0  \cf3 rst\cf0 ;\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 void\cf0  helper(List<Integer> \cf3 rst\cf0 , \cf2 int\cf0  \cf3 start\cf0 , \cf2 int\cf0  \cf3 end\cf0 , \cf2 int\cf0  \cf3 len\cf0 , \cf2 int\cf0  \cf3 curr\cf0 ) \{\
		\cf2 if\cf0  (\cf3 len\cf0  == 0) \{\
			\cf2 if\cf0  (\cf3 curr\cf0  >= \cf3 start\cf0  && \cf3 curr\cf0  <= \cf3 end\cf0 ) \
				\cf3 rst\cf0 .add(\cf3 curr\cf0 );\
			\cf2 return\cf0 ;\
		\}\
		\cf2 int\cf0  \cf3 last\cf0  = \cf3 curr\cf0  % 10;\
		\cf2 if\cf0  (\cf3 last\cf0  == 0) \{\
			helper(\cf3 rst\cf0 , \cf3 start\cf0 , \cf3 end\cf0 , \cf3 len\cf0  - 1, \cf3 curr\cf0  * 10 + 1);\
		\} \cf2 else\cf0  \cf2 if\cf0  (\cf3 last\cf0  == 9) \{\
			helper(\cf3 rst\cf0 , \cf3 start\cf0 , \cf3 end\cf0 , \cf3 len\cf0  - 1, \cf3 curr\cf0  * 10 + 8);\
		\} \cf2 else\cf0  \{\
			helper(\cf3 rst\cf0 , \cf3 start\cf0 , \cf3 end\cf0 , \cf3 len\cf0  - 1, \cf3 curr\cf0  * 10 + \cf3 last\cf0  - 1);\
			helper(\cf3 rst\cf0 , \cf3 start\cf0 , \cf3 end\cf0 , \cf3 len\cf0  - 1, \cf3 curr\cf0  * 10 + \cf3 last\cf0  + 1);\
		\}\
	\}\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Finding Words and Print Coordinates\

\f1\b0\fs22 \
\pard\pardeftab720
\cf0 	\cf2 public\cf0  \cf2 static\cf0  Set<List<String>> findWord(\cf2 char\cf0 [][] \cf3 grid\cf0 , String \cf3 word\cf0 ) \{\
		Set<List<String>> \cf3 rst\cf0  = \cf2 new\cf0  HashSet<>();\
		\cf2 if\cf0  (\cf3 word\cf0  == \cf2 null\cf0  || \cf3 word\cf0 .length() == 0)\
			\cf2 return\cf0  \cf3 rst\cf0 ;\
		\cf2 if\cf0  (\cf3 grid\cf0  == \cf2 null\cf0  || \cf3 grid\cf0 .\cf6 length\cf0  == 0 || \cf3 grid\cf0 [0] == \cf2 null\cf0  || \cf3 grid\cf0 [0].\cf6 length\cf0  == 0)\
			\cf2 return\cf0  \cf3 rst\cf0 ;\
		\
		\cf2 int\cf0 [][] \cf3 direction\cf0  = \{ \{ -1,0 \},\{ 1,0 \},\{ 0,-1 \},\{ 0,1 \},\{ -1,-1 \},\{ -1,1 \},\{ 1,-1 \},\{ 1,1 \} \};\
		\cf2 for\cf0  (\cf2 int\cf0  \cf3 row\cf0  = 0; \cf3 row\cf0  < \cf3 grid\cf0 .\cf6 length\cf0 ; \cf3 row\cf0 ++) \{\
			\cf2 for\cf0  (\cf2 int\cf0  \cf3 col\cf0  = 0; \cf3 col\cf0  < \cf3 grid\cf0 [0].\cf6 length\cf0 ; \cf3 col\cf0 ++) \{\
				\cf2 if\cf0  (\cf3 grid\cf0 [\cf3 row\cf0 ][\cf3 col\cf0 ] == \cf3 word\cf0 .charAt(0)) \{\
					dfs(\cf3 rst\cf0 , \cf3 grid\cf0 , \cf3 word\cf0 , 0, \cf3 row\cf0 , \cf3 col\cf0 , \cf2 new\cf0  ArrayList<String>(), \cf3 direction\cf0 );\
				\}\
			\}\
		\}\
		\cf2 return\cf0  \cf3 rst\cf0 ;\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 void\cf0  dfs(Set<List<String>> \cf3 rst\cf0 , \cf2 char\cf0 [][] \cf3 grid\cf0 , String \cf3 word\cf0 , \cf2 int\cf0  \cf3 curr\cf0 , \
			\cf2 int\cf0  \cf3 row\cf0 , \cf2 int\cf0  \cf3 col\cf0 , List<String> \cf3 list\cf0 , \cf2 int\cf0 [][] \cf3 direction\cf0 ) \{\
		\cf2 if\cf0  (\cf3 curr\cf0  == \cf3 word\cf0 .length()) \{\
			\cf3 rst\cf0 .add(\cf2 new\cf0  ArrayList<>(\cf3 list\cf0 ));\
			\cf2 return\cf0 ;\
		\}\
		\cf2 if\cf0  (\cf3 row\cf0  < 0 || \cf3 row\cf0  >= \cf3 grid\cf0 .\cf6 length\cf0  || \cf3 col\cf0  < 0 || \cf3 col\cf0  >= \cf3 grid\cf0 [0].\cf6 length\cf0 )\
			\cf2 return\cf0 ;\
		\cf2 if\cf0  (\cf3 grid\cf0 [\cf3 row\cf0 ][\cf3 col\cf0 ] != \cf3 word\cf0 .charAt(\cf3 curr\cf0 ))\
			\cf2 return\cf0 ;\
		\
		\cf3 grid\cf0 [\cf3 row\cf0 ][\cf3 col\cf0 ] = \cf4 '#'\cf0 ;\
		\cf3 list\cf0 .add(\cf4 "("\cf0  + \cf3 row\cf0  + \cf4 ","\cf0  + \cf3 col\cf0  + \cf4 ")"\cf0 );\
		\cf2 for\cf0  (\cf2 int\cf0  \cf3 i\cf0  = 0; \cf3 i\cf0  < \cf3 direction\cf0 .\cf6 length\cf0 ; \cf3 i\cf0 ++) \{\
			dfs(\cf3 rst\cf0 , \cf3 grid\cf0 , \cf3 word\cf0 , \cf3 curr\cf0  + 1, \cf3 row\cf0  + \cf3 direction\cf0 [\cf3 i\cf0 ][0], \cf3 col\cf0  + \cf3 direction\cf0 [\cf3 i\cf0 ][1], \cf3 list\cf0 , \cf3 direction\cf0 );\
		\}\
		\cf3 list\cf0 .remove(\cf3 list\cf0 .size() - 1);\
		\cf3 grid\cf0 [\cf3 row\cf0 ][\cf3 col\cf0 ] = \cf3 word\cf0 .charAt(\cf3 curr\cf0 );\
	\}\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Largest Sum Subarray\

\f1\b0\fs22 \
\pard\pardeftab720
\cf0 	\cf2 public\cf0  \cf2 static\cf0  List<Integer> maximumSubarray(\cf2 int\cf0 [] \cf3 nums\cf0 ) \{\
		List<Integer> \cf3 rst\cf0  = \cf2 new\cf0  ArrayList<>();\
		\cf2 if\cf0  (\cf3 nums\cf0  == \cf2 null\cf0  || \cf3 nums\cf0 .\cf6 length\cf0  <= 1)\
			\cf2 return\cf0  \cf3 rst\cf0 ;\
		\
		\cf2 int\cf0  \cf3 maxEndHere\cf0  = \cf3 nums\cf0 [0];\
		\cf2 int\cf0  \cf3 maxTotal\cf0  = \cf3 nums\cf0 [0];\
		List<Integer> \cf3 tmp\cf0  = \cf2 new\cf0  ArrayList<>();\
		\cf3 tmp\cf0 .add(\cf3 nums\cf0 [0]);\
		\
		\cf2 for\cf0  (\cf2 int\cf0  \cf3 i\cf0  = 1; \cf3 i\cf0  < \cf3 nums\cf0 .\cf6 length\cf0 ; \cf3 i\cf0 ++) \{\
			\cf2 if\cf0  (\cf3 maxEndHere\cf0  + \cf3 nums\cf0 [\cf3 i\cf0 ] < \cf3 nums\cf0 [\cf3 i\cf0 ]) \{ \cf5 // same ending; new start or not?\cf0 \
				\cf3 tmp\cf0 .clear();\
			\}\
			\cf3 tmp\cf0 .add(\cf3 nums\cf0 [\cf3 i\cf0 ]);\
			\cf3 maxEndHere\cf0  = Math.max(\cf3 maxEndHere\cf0  + \cf3 nums\cf0 [\cf3 i\cf0 ], \cf3 nums\cf0 [\cf3 i\cf0 ]);\
			\
			\cf2 if\cf0  (\cf3 maxEndHere\cf0  > \cf3 maxTotal\cf0 ) \{\
				\cf3 maxTotal\cf0  = \cf3 maxEndHere\cf0 ;\
				\cf3 rst\cf0  = \cf2 new\cf0  ArrayList<>(\cf3 tmp\cf0 );\
			\}\
		\}\
		\cf2 return\cf0  \cf3 rst\cf0 .size() >= 2 ? \cf3 rst\cf0  : \cf2 new\cf0  ArrayList<Integer>();\
	\}\
}